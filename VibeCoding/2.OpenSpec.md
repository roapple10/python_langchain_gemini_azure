OpenSpec 規範驅動開發完整實戰指南

支援 Cursor、Claude Code、Codex

## 概述

你有沒有遇到過這種情況？滿懷期待地讓 AI 助手寫程式碼，結果它理解錯了需求，寫了一堆你不想要的功能；或者你想讓它改個小地方，結果它把整個檔案都改亂了；又或者幾輪對話後，AI 完全忘了你最初想要什麼，程式碼越改越偏…

今天要介紹的 OpenSpec，是一個專門為 AI 編碼助手設計的「規範驅動開發」工具。簡單說，就是**在 AI 寫任何程式碼之前，先和它把需求說清楚、寫明白**。

聽起來很簡單？但它解決的卻是 AI 程式設計最核心的痛點。

## 一、為什麼需要 OpenSpec？

### AI 程式設計的「甜蜜陷阱」

AI 編碼助手確實強大。給它一個提示，幾秒鐘就能生成一大段程式碼。但這種「快」背後，藏著一個很大的問題：

**當需求只存在於聊天記錄裡時，AI 會變得非常不可預測。**

比如你說「給我加個用戶登入功能」，AI 可能給你：

* 加了郵箱登入（但你想要手機號）
* 加了第三方登入（但你不需要）
* 改了資料庫結構（但你只想加個簡單的表單）

更糟糕的是，當你發現問題想修正時，AI 已經「忘記」了上下文，或者理解成了另一個意思，程式碼越改越亂。

### OpenSpec 的核心理念

OpenSpec 的核心思想很簡單：**把需求寫成規範，讓 AI 按照規範來寫程式碼**。

這不是簡單的「寫個需求文件」，而是一套完整的**規範驅動開發（Spec-Driven Development）**工作流：

1. **起草提案**：把需求寫成結構化的規範提案
2. **審查對齊**：AI 會問你澄清問題，確保理解正確
3. **實現任務**：AI 按照規範和任務清單來實現
4. **歸檔更新**：完成後更新規範文件，形成可追溯的歷史

這樣，需求不再是「聊天記錄裡的幾句話」，而是**專案裡的一份正式文件**，可以版本控制、可以審查、可以追溯。

## 二、OpenSpec 到底是什麼？

### 一句話解釋

OpenSpec 是一個**輕量級的規範驅動開發工具**，專門為使用 AI 編碼助手（如 Cursor、Claude Code、GitHub Copilot）的開發者設計，讓 AI 寫程式碼的過程變得可控、可追溯、可迭代。

### 核心特點

#### 1. 輕量級設計

OpenSpec 不是一個「框架」或「平台」，它只是一套**文件結構和命令工具**。你不需要改變現有的開發流程，只需要：

* 在專案根目錄建立一個 `openspec/` 資料夾
* 用 Markdown 寫規範文件
* 用命令工具來管理變更提案

就是這麼簡單。

#### 2. 工具相容性強

OpenSpec 不綁定任何特定的 AI 工具。你可以：

* 在 Cursor 裡用 OpenSpec
* 在 Claude Code 裡用 OpenSpec
* 在 GitHub Copilot 裡用 OpenSpec
* 甚至手動編輯規範文件，然後讓任何 AI 工具來實現

只要規範文件格式一致，任何 AI 工具都能理解。

#### 3. 為現有專案設計

OpenSpec 特別適合**改進現有專案**（從 1 到 N），而不是從零開始建新專案。

它假設你已經有一個正在運行的專案，想要：

* 加新功能
* 改進現有功能
* 重構程式碼
* 修復 Bug

這些場景下，OpenSpec 能幫你：

* 明確變更範圍
* 記錄技術決策
* 追蹤變更歷史
* 避免 AI 改錯地方

#### 4. 變更可追溯

每個變更提案都會：

* 建立獨立的資料夾
* 記錄變更動機、設計決策、實現任務
* 可以版本控制
* 可以審查、討論、迭代

這樣，專案的每個變更都有完整的「檔案」，而不是散落在聊天記錄裡。

## 三、OpenSpec 的工作流程

### 第 1 步：起草提案

當你想要加一個新功能或改進現有功能時，先建立一個「變更提案」。

提案包含：

* **動機**：為什麼要做這個變更？
* **範圍**：具體要做什麼？
* **設計**：技術方案是什麼？
* **任務**：需要做哪些具體工作？

你可以手動寫，也可以讓 AI 幫你生成。OpenSpec 會根據你的描述，生成結構化的提案文件。

### 第 2 步：審查對齊

AI 會自動分析你的提案，找出：

* **模糊點**：哪些地方不夠明確？
* **衝突**：是否與現有設計衝突？
* **風險**：技術風險在哪裡？

然後 AI 會問你澄清問題，確保理解正確。這個階段很重要，因為**在寫程式碼之前把需求說清楚，比寫完後再改要省事得多**。

### 第 3 步：實現任務

提案通過審查後，AI 會按照任務清單來實現。

每個任務都是：

* **具體的**：明確要做什麼
* **可測試的**：有明確的驗證標準
* **獨立的**：可以單獨完成和測試

AI 會一個任務一個任務地實現，每完成一個就標記，遇到問題會詢問你的決策。

### 第 4 步：歸檔更新

實現完成並測試通過後，將變更歸檔。

歸檔會：

* 更新規範文件，記錄新的狀態
* 標記提案為「已完成」
* 生成變更摘要

這樣，專案的規範文件始終反映最新狀態，同時保留完整的變更歷史。

## 四、實戰演示：給 ForestFocus 添加自訂時長

### 背景介紹

ForestFocus 是一個 Web 的專注力應用，類似 Forest。用戶可以開始一個 25 分鐘的專注會話來「種植」一棵樹，樹會通過 5 個階段成長；取消或退出會殺死這棵樹；完成會話會將樹保存到個人森林中。應用顯示倒數計時、暫停/恢復、瀏覽器通知，並使用 localStorage 本地儲存完成的/放棄的會話記錄，顯示森林網格和統計資料（總樹數、總專注時間、今日數量、每日連續記錄）。原本只支援固定的 25 分鐘 Pomodoro 時長，現在要加一個功能：讓用戶可以自訂專注時長（1-180 分鐘）。

### 準備工作

#### 1. 安裝 OpenSpec

**前置需求：**
- **Node.js >= 20.19.0** - 使用 `node --version` 檢查版本

**步驟 1：全域安裝 CLI**

```bash
npm install -g @fission-ai/openspec@latest
```

驗證安裝：

```bash
openspec --version
```

#### 2. 初始化專案

導航到你的專案目錄：

```bash
cd my-project
```

執行初始化：

```bash
openspec init
```
選cursor

**初始化過程中會發生什麼：**

* 系統會提示你選擇任何原生支援的 AI 工具（Claude Code、CodeBuddy、Cursor、OpenCode 等）；其他助手總是依賴共享的 `AGENTS.md` 存根
* OpenSpec 會自動為你選擇的工具配置斜線命令，並在專案根目錄寫入一個受管理的 `AGENTS.md` 交接文件
* 在專案中建立新的 `openspec/` 目錄結構

**設定完成後：**

* 主要的 AI 工具可以在沒有額外配置的情況下觸發 `/openspec` 工作流
* 執行 `openspec list` 驗證設定並查看任何活動變更
* 如果你的編碼助手沒有立即顯示新的斜線命令，請重新啟動它。斜線命令在啟動時載入，所以重新啟動可確保它們出現

#### 3. 填充專案資訊

編輯 `openspec/project.md`，填寫專案基本資訊：

* 專案名稱
* 技術棧
* 架構說明
* 現有功能概述

這些資訊會幫助 AI 更好地理解你的專案。

### Step 1：建立變更提案

在 Claude Code（或 Cursor）中輸入：

```
/openspec:propose Add custom focus duration feature

Allow users to set custom focus durations from 1 to 180 minutes, 
instead of only the fixed 25-minute Pomodoro. Should include:
- Duration picker UI
- Save user preference
- Update timer logic
- Update statistics display
```

AI 會生成一個提案，並問你澄清問題。

#### 問題 1：時長範圍

AI 可能會問：時長範圍是 1-180 分鐘，是否需要限制某些值（比如必須是 5 的倍數）？

#### 問題 2：UI 設計

AI 可能會問：時長選擇器應該放在哪裡？主畫面？設定頁面？還是彈出視窗？

#### 問題 3：統計影響

AI 可能會問：統計資料中的「完成的 Pomodoro 數量」應該如何計算？是按實際時長換算，還是只計算完整的 25 分鐘？

#### 問題 4：向後相容

AI 可能會問：現有用戶的資料如何處理？預設值是什麼？

#### 問題 5：樹木生長

AI 可能會問：樹木的生長動畫是否需要根據時長調整？還是保持固定速度？

### 我的回答

```
1. Duration Range: 1-180 minutes, any integer value allowed. 
   No restrictions on multiples.

2. UI Location: Add duration selector on main screen, 
   above the start button. Use quick-select buttons (15, 25, 45, 60 min) 
   + slider + text input. NOT in Settings.

3. Statistics Impact: Show both actual time AND equivalent Pomodoro count.
   Formula: pomodoroCount = ceil(duration / 25.0)
   Example display: "45 min (≈2 🍅)"

4. Duration Persistence: Remember last selected duration using localStorage.
   First visit defaults to 25 min, then uses user's last choice.

5. Tree Growth: Proportional to duration. 
   25 min = full growth, other durations scale proportionally.
```

AI 會根據你的回答，生成完整的提案文件。

### Step 2：審查和驗證

查看生成的提案：

```bash
# 查看提案文件
cat openspec/changes/add-custom-focus-duration/proposal.md

# 查看任務清單
cat openspec/changes/add-custom-focus-duration/tasks.md

# 使用互動式儀表板
openspec view
```

重點檢查：

* **proposal.md**：了解功能動機和整體設計
* **tasks.md**：確認任務分解是否合理
* **specs/ui-components/spec.md**：UI 互動細節
* **specs/timer-management/spec.md**：核心計時邏輯

如果需要調整，可以直接在 Claude Code 中說：

```
請修改 add-custom-focus-duration 提案：
- 將最大時長從 180 分鐘改為 120 分鐘
- 添加一個新的快捷按鈕：30 分鐘
```

或者手動編輯文件。

### Step 3：實現功能

提案通過審查後，開始實現：

```
/openspec:apply add-custom-focus-duration
```

Claude Code 會：

1. 讀取 `tasks.md` 中的所有任務
2. 按順序逐個實現
3. 自動標記完成的任務
4. 生成或修改程式碼檔案
5. 遇到問題時詢問你的決策

#### Phase 1：資料模型更新

AI 會先更新資料模型，添加 `duration` 欄位。

#### Phase 2：時長持久化

實現使用 localStorage 儲存用戶選擇的時長。

#### Phase 3：計時服務增強

更新計時邏輯，支援自訂時長。

#### Phase 4：時長選擇器 UI

建立時長選擇器元件，包含快捷按鈕、滑桿和文字輸入。

#### Phase 5：介面整合

將時長選擇器整合到主畫面。

#### Phase 6：統計顯示

更新統計顯示，同時顯示實際時長和等效 Pomodoro 數量。

### 插曲：發現並修復 Bug

在實現過程中，AI 可能會發現一些問題，比如：

* 現有程式碼的邏輯衝突
* 邊界情況沒有處理
* 效能問題

AI 會詢問你的決策，然後一起修復。這就是 OpenSpec 的優勢：**在實現過程中發現問題，而不是上線後才發現**。

### Step 4：歸檔變更

測試全部通過後，歸檔變更：

```
/openspec:archive add-custom-focus-duration
```

或者使用終端：

```bash
openspec archive add-custom-focus-duration --yes
```

歸檔會：

* 更新規範文件，記錄新功能
* 標記提案為「已完成」
* 生成變更摘要

然後提交程式碼：

```bash
git add .
git commit -m "feat: add custom focus duration feature

- Support 1-180 minute custom durations
- Quick-select buttons and slider input
- Proportional tree growth
- Persistent preferences
- Enhanced statistics with Pomodoro tracking

Implemented via OpenSpec workflow"

git push origin main
```

## 五、OpenSpec 的核心優勢

### 1. 需求明確性

通過提案和澄清問題，確保 AI 理解正確，減少返工。

### 2. 技術決策有據可查

每個變更的設計決策都記錄在提案中，可以追溯、可以討論。

### 3. 可追溯的完整歷史

每個變更都有完整的「檔案」，包括動機、設計、實現、測試。

### 4. 迭代友好

規範文件可以持續迭代，程式碼可以「再生一次」去對齊。

### 5. 規範即文件

規範文件就是最好的文件，不需要另外維護文件。

## 六、OpenSpec 適合什麼場景？

### 最適合的場景

#### 1. 改進現有專案（1→n）

OpenSpec 特別適合在現有專案基礎上添加功能、改進功能、重構程式碼。

#### 2. 需要高品質的場景

當你需要高品質、可維護的程式碼時，OpenSpec 的規範驅動流程能幫你達到目標。

#### 3. 使用 AI 編碼助手

如果你經常使用 Cursor、Claude Code、GitHub Copilot 等工具，OpenSpec 能讓這些工具變得更可控、更可靠。

### 不太適合的場景

#### 1. 原型快速驗證

如果你只是想快速驗證一個想法，不需要這麼正式的流程。

#### 2. 一次性腳本

對於簡單的一次性腳本，OpenSpec 可能過於複雜。

#### 3. 需求極度不明確

如果需求極度不明確，連你自己都不知道要做什麼，OpenSpec 也幫不了你。

## 七、上手 OpenSpec：5 分鐘快速開始

### 1. 安裝（1 分鐘）

**前置需求：**
- **Node.js >= 20.19.0** - 使用 `node --version` 檢查版本

**全域安裝 CLI：**

```bash
npm install -g @fission-ai/openspec@latest
```

驗證安裝：

```bash
openspec --version
```

### 2. 初始化專案（2 分鐘）

導航到你的專案目錄：

```bash
cd my-project
```

執行初始化：

```bash
openspec init
```

**初始化過程中會發生什麼：**

* 系統會提示你選擇任何原生支援的 AI 工具（Claude Code、CodeBuddy、Cursor、OpenCode 等）
* OpenSpec 會自動為你選擇的工具配置斜線命令，並在專案根目錄寫入一個受管理的 `AGENTS.md` 交接文件
* 在專案中建立新的 `openspec/` 目錄結構

**設定完成後：**

* 主要的 AI 工具可以在沒有額外配置的情況下觸發 `/openspec` 工作流
* 執行 `openspec list` 驗證設定並查看任何活動變更
* 如果編碼助手沒有立即顯示新的斜線命令，請重新啟動它

### 3. 填充專案資訊（2 分鐘）

編輯 `openspec/project.md`，填寫：

* 專案名稱和描述
* 技術棧和架構
* 現有功能概述
* 開發規範和約定

### 4. 建立第一個提案（開始真正的工作）

在 Claude Code（或 Cursor）中輸入：

```
/openspec:propose [你的功能描述]
```

AI 會幫你生成提案，並問你澄清問題。回答問題後，AI 會生成完整的提案和任務清單。

然後執行：

```
/openspec:apply [提案名稱]
```

AI 會按照任務清單來實現功能。

## 八、一些使用建議

### 建議 1：第一個提案從小功能開始

不要一開始就做一個大功能，先從一個小功能開始，熟悉流程。

### 建議 2：認真對待澄清問題

AI 問的澄清問題很重要，認真回答能避免後續返工。

### 建議 3：提案階段多迭代

提案階段多花時間，確保設計正確，比實現後再改要省事。

### 建議 4：測試後再歸檔

實現完成後，一定要測試，確認沒問題後再歸檔。

### 建議 5：規範文件是活的

規範文件不是寫完就不動了，要隨著專案發展持續更新。

## 九、OpenSpec vs 其他方案

### vs 直接讓 AI 寫程式碼

**直接讓 AI 寫程式碼**：
* 需求存在聊天記錄裡，不可追溯
* AI 理解錯誤，容易返工
* 幾輪對話後，AI 可能忘記上下文

**OpenSpec**：
* 需求寫成規範文件，可版本控制
* 通過澄清問題，確保理解正確
* 規範文件是「單一真實來源」，不會遺忘

### vs 傳統需求文件

**傳統需求文件**：
* 寫完後容易「變廢」
* 程式碼和文件容易不同步
* 變更時要手工同步多處

**OpenSpec**：
* 規範文件是「一等公民」，程式碼服務規範
* 變更時改規範，程式碼可以「再生一次」
* 規範文件就是最好的文件

### vs spec-kit / Kiro

**spec-kit / Kiro**：
* 更適合從零開始建新專案
* 流程更複雜，學習成本更高
* 需要改變現有開發流程

**OpenSpec**：
* 更適合改進現有專案（1→n）
* 輕量級設計，學習成本低
* 不需要改變現有開發流程

## 十、總結

### OpenSpec 解決的核心問題

* **需求不明確**：通過提案和澄清問題，確保 AI 理解正確
* **變更不可追溯**：每個變更都有完整的「檔案」
* **技術決策無據可查**：設計決策記錄在提案中
* **迭代困難**：規範文件可以持續迭代，程式碼可以「再生一次」

### 四步工作流

1. **起草提案**：把需求寫成結構化的規範提案
2. **審查對齊**：AI 問澄清問題，確保理解正確
3. **實現任務**：AI 按照規範和任務清單來實現
4. **歸檔更新**：完成後更新規範文件，形成可追溯的歷史

### 核心價值

* **可控**：需求明確，AI 按照規範實現
* **可追溯**：每個變更都有完整歷史
* **可迭代**：規範文件可以持續更新
* **輕量級**：不需要改變現有開發流程

### 適用場景

* 改進現有專案（1→n）
* 需要高品質的場景
* 使用 AI 編碼助手

### 我的體驗

使用 OpenSpec 後，AI 寫程式碼的過程變得可控、可追溯、可迭代。不再需要擔心 AI 理解錯誤、改錯地方、忘記上下文。規範文件就是最好的文件，不需要另外維護文件。

### 開始使用

1. 安裝 OpenSpec：`npm install -g @fission-ai/openspec@latest`
2. 初始化專案：`openspec init`
3. 填充專案資訊：編輯 `openspec/project.md`
4. 建立第一個提案：`/openspec:propose [功能描述]`

就是這麼簡單。

## 寫在最後

OpenSpec 不是「另一個 AI 程式碼生成工具」，而是一套**規範驅動開發的方法論和工具鏈**。它把「規範=一等公民」的理念落實到具體的文件結構和命令中，讓使用 AI 編碼助手的開發者可以用統一的方式從需求走到實現，減少意圖走樣、提高可維護性、形成可追溯的變更歷史。

如果你正在使用 AI 編碼助手，並且想要一種更可控、更可追溯的開發方式，OpenSpec 值得一試。

---

**參考資料：**
- [OpenSpec 官方網站](https://openspec.dev/)
- [GitHub Repository](https://github.com/roapple10/OpenSpec)

